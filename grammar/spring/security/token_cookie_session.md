## Access/Refresh token 저장 위치

### 개요

    시큐리티를 다루면서 인증/인가의 중요성이 커지게 되고, 인증/인가 구현 중 여러 구글링 결과 토큰의 저장위치에 대해서 고민이 되는 상황에 정리가 필요하여 이 글을 쓰게 되었다.

### 사용자 인증

    - "시스템이나 애플리케이션에 접근하려는 사용자가 실제로 그 사용자인지 확인하는 과정"

    - 이미 사용자 인증을 마친 회원이 페이지를 이동할 때마다 사용자 인증을 하게 된다면 사용자에게는 굉장히 불편한 서비스가 될 것이다. 이런 문제로 사용자 인증 방식들을 보안성, 사용자 경험, 확장성을 중심으로 비교해 보고 선택함이 중요하다.

    - 사용자 인증은 크게 session, token 인증 방식으로 나눌 수 있다.

### Session 인증 방식 특징

    서버에 상태를 저장하는 상태 유지(stateful)이다.
    사용자가 로그인을 서버로 요청하면, 요청 정보가 DB와 일치하는지 확인하고 사용자의 세션을 생성한다. 이때 생성한 세션 id는 서버의 저장소(메모리, DB)에 저장된다. (이 값을 서버에 저장하기 때문에 stateful 이라 한다.)

    이 후로는 쿠키에 담아 사용자의 후속 요청마다 세션 ID가 담긴 쿠키를 서버에 전송하게 되고, 해당 세션 id가 저장소에 존재하는지 확인하는 식으로 사용자 검증을 한다.

    이러한 방식은 서버에서 인증을 관리하기 때문에, 클라이언트 측에서 정보가 누출될 위험이 적다는 보안적인 장점이 있다.

    하지만 빈번히 발생하는 사용자의 요청마다 DB에 접근한다는 것은 응답 속도 저하를 일으키는 원인이 된다.

![stateful](/grammar/img/stateful.png)    

### Token 인증 방식 사용 이유

    토큰 인증은 세션 인증과 반대로 서버에 상태를 저장하지 않는 상태 비저장(stateless)이 가장 큰 특정이다.

    즉, 서버는 사용자의 정보를 검증하기 위해 "DB를 거치지 않고 오로지 토큰만 사용한 방법으로 사용를 검증한다."

    기존 세션 인증 방식의 가장 큰 단점은 응답 속도 저하로 인한 서버 부하(사용자 경험 저하)와 확장에 어려움이 있다는 점이다. 반면, 토큰 인증 방식은 DB를 거치지 않기 때문에 응답속도 저하 문제를 해결할 수 있다.

    또한, 모바일 환경에서는 IP로 세션을 관리하는 경우도 있는데, 이런 경우는 토큰 방식이 더 선호된다.

    -> 즉, 세션 인증 방식에 비해 응답속도, 확장성 면에서 우수하여 토큰 방식을 사용하는 것이다.

![stateless](/grammar/img/stateless.png)        

### Token 인증 방식 단점

    토큰 탈취의 위험이 단점이다. 세션이 서버에 관리되는 장점과 상반되는 이유. 클라이언트 자체에서 탈취되거나, 악성코드로 탈취될 가능성도 있고, 클라이언트에서 서버로 전송되는 동안에도 탈취될 가능성이 있다.

    -> 이번 글은 두 방식 중 세션의 단점을 보완하기 위해 등장한 토큰 인증 방식을 선택, 토큰 탈취에 대한 방비책에 대해서 작성하겠다.

### Access Token        

    주로 OAuth 2.0 프로토콜에서 사용되는 토큰이다.
    access는 사용자의 인증과 권한을 나타내는 단기 유효 토큰(문자열)로, 클라이언트가 서버에 API 요청을 보낼 때 이 토큰을 헤더에 포함하여 요청을 보내고, access가 유효한지 확인하여 사용자를 검증한다.

    session = 서버가 인증 정보를 관리, 
    access  = 클라이언트가 인증 정보를 직접 관리

    물론, access의 경우에도 서버에 인증 정보를 관리할 수 있지만, 앞서 session 방식의 단점을 그대로 안고 가기 때문에 권장되는 방식이 아니다.

### Access Token & JWT

    access 토큰은 문자열 형식으로 구성되어 있으며, 발급되는 토큰 종류에 따라 구조화된 모양일 수 있고, 해석할 수 없는 단순한 문자열일 수 있다.

    이때 다양한 토큰 형식 중, JWT 형식이 stateless (상태 저장 없음)하다는 장점 덕분에 주로 사용된다. stateless 하다는 특성은 다시 말해, 서버에서 access 토큰 자체를 저장할 필요가 없다. DB 접근 또한 없을 뿐더러, 서버 인스턴스가 여러 개 있을 때에도 쉽게 확장할 수 있다는 것이다.

    이런 stateless 한 특징은 JWT 구조에서 비롯된다.
    JWT = Header + Payload + Signature 로 구성되어 있으며, 한 줄의 문자열에서 .(점)을 이용해 세 부분으로 구분된다.

![jwt_structure](/grammar/img/JWT_structure.png)

### JWT Structure

    Header    : 토큰의 유형과 서명 알고리즘을 포함
    Payload   : 사용자 정보 + claim (id, role, expired)이 포함
                (payload 떄문에 서버가 별도 DB 조회 없이도 사용자 정보를 확인) = 요청 처리 속도 UP + 서버 부하 Down -> Self-contained 
    Signature : Header + Payload 조합한 후, 헤더의 서명 알고리즘과 비밀 키를 사용 -> 클라이언트가 토큰 변조 방지

    -> 위 세 부분은 Base64 Url 인코딩 되어 하나의 문자열로 결합되어 JWT 토큰을 구성하게 된다. 이렇게 구성된 JWT는 필요한 모든 정보와 서명 부분을 토큰 자체에 포함하고 있으므로, 서버에서 별도의 세션 저장소를 유지할 필요가 없어진다.

### Access Token 저장 위치

    JWT를 관리하는 방식으로는 Local, Session, Cookie, Memory 에 저장하는 방식으로 나눌 수 있다.

    1. Local
    - 클라이언트 측에 데이터를 영구적으로 저장하는 방법이다.
    - 브라우저를 닫아도 데이터가 유지되며, 명시적으로 삭제하지 않는 한 계속 존재
    - 그러나 XSS(악성 코드를 브라우저에서 실행 되도록 하는 공격 방식) 공격에 취약하여, 로컬 스토리지에 저장된 엑세스 토큰을 탈취할 수 있는 위험이 있다.

    2. Session    
    - 브라우저가 닫히면 데이터가 삭제되며, 같은 탭에서만 유효하다는 특징이 있다.
    - 로컬 보다는 보안적인 측면에서는 안전하지만, 여기 또한 XSS에 취약하다.

    3. Cookie
    - HTTP의 Stateless 특성을 보완하기 위해 등장한 데이터, 따라서 모든 클라이언트 요청에 자동적으로 포함된다. 이는 access 토큰에 사용될 때에도, 클라이언트에서 쿠키를 별도로 포함시키지 않아도 된다는 뜻이다.

    - 쿠키는 만료 날짜를 지정하는 "영구 쿠키" vs 브라우저가 닫힐 때 삭제되는 "세션 쿠키"로 구분된다.

    - 특히 쿠키는 앞선 두 방식에서의 XSS 공격 취약점을 어느 정도 예방할 수 있다. HttpOnly 플래그를 사용하여 JavaScript에서 쿠키에 접근할 수 없게 함으로써 XSS 공격에 대한 보안을 높이는 방식이다.
    
    - 하지만, XSS 공격은 다양한 방법으로 이루어 지므로 완벽하게 방어가 된다고 볼 수 없기에, 추가적인 보안 조치가 필요하다.
    
    - 또한, Secure 플래그를 사용하면, HTTPS 연결에서만 쿠키가 전송되게 하여 중간자 공격 (MITM)으로 부터 쿠키를 보호할 수 있으며, SameSite 쿠키 속성을 설정하면 CSRF 공격을 방어할 수 있다. 

    4. Memory
    - access 토큰을 클라이언트 서버의 메모리에 저장하는 방식
      ex) JavaScript의 private 변수에 JWT를 저장하는 것이다.

    - 매 요청 마다, API 호출 시, access 토큰에 접근이 쉬어지지만, 브라우저의 메모리는 세션 단위로 관리되기 때문에 페이지를 이동하면 access 토큰이 
    소멸하는 문제 발생

    - 따라서 Memory 저장 방법은 SPA(Single Page Application)에서 주로 사용된디.
      ex) React를 사용하여 클라이언트 서버를 구현했다면, 페이지가 이동하는 것처럼 보여도 실제로는 이동하지 않기 때문에 private 변수가 그대로 유지된다. 

      하지만, 페이지를 새로 고침한다면, private 변수가 소멸되기 때문에 다시 로그인을 해주어햐 되는 상황이 발생한다.

    -> 메모리에 저장 시, 스크립트가 메모리 공간을 직접적으로 제어할 수 없기 때문에 XSS 공격에 의해 쉽게 탈취될 수 없다.

    정리
    - 이 네 가지 방법 중 로컬 스토리지와 세션 스토리지의 경우, XSS 공격에 매우 취약하여 권장하지 않는다.
    - 메모리 & 쿠키 경우에도 완벽하지 않지만, 다른 방식에 비해 비교적 안전한 방식으로 많이 사용된다.
    - access 토큰만 사용하는 경우에서 불편하게 보일 수 있지만, 이후에 다루는 Refresh 토큰까지 고려해 본다면 충분히 안정적으로 사용 가능한 방식이다.

### Access Token 사용자 인증 방식

    이제는 JWT를 통해 어떻게 사용자 인증이 이루어지는지를 알아보자.
    JWT 와 쿠키를 이용한 access 토큰 인증 방식은 간단하게 아래와 같은 플로우로 이루어진다.

![jwt_user_authentication](/grammar/img/jwt_user_authentication.png)

    1. access token 생성
    - 로그인 요청 시, JWT를 생성하여 클라이언트에게 반환하는 과정
    - 로그인 요청 : 사용자가 로그인 정보를 입력하고 서버에 로그인 요청을 보낸다.
    - JWT 발급 : 서버는 사용자의 인증 정보를 DB와 일치하는지 확인한 후, JWT를 생성하여 클라이언트에 반환한다.

    2. access token 사용
    - 서버에서는 JWT가 스스로 정보를 인증하므로 DB에서 사용자 정보와 일치하는지 검증할 필요가 없다.
    - 클라이언트 측에서는 헤더에 JWT를 모든 요청에 포함하여 사용자 인증에 사용한다.

    후속 요청 : 클라이언트가 서버에 요청을 보낼 때, 헤더에 access 토큰을 포함 (쿠키의 경우 자동 포함)
    서버에서 JWT 검증 : 서버는 요청받은 access 토큰에서 사용자의 인증 상태를 확인한다.

    -> 이런 인증 방식의 사용이 무수히 일어나도, 서버에서 사용자 인증을 위해 DB에 접근하는 부분은 JWT를 발급하는 로그인 부분뿐이다. 이러한 점이 JWT의 stateless 한 특징이 가장 도드라지는 부분이다.

### Access Token 로그아웃 방식

    사용자 인증이 이루어지는 부분을 생각해 보면, 단순히 access 토큰을 사용하기 때문에 이 부분만 무효화해 주면 된다는 결론에 이를 수 있다.

    1. 메모리의 경우 Access 토큰 제거
    클라이언트 서버 private 변수에 Access 토큰을 저장한 경우, Access 토큰 자체를 제거해 주면 된다. 간단히 null 처리를 통해 로그아웃을 구현할 수 있따.

    2. HTTP-Only 쿠키의 경우 Access Token 만료시키기
    이 경우에는 JavaScript로 쿠키에 접근하는 방법은 불가능하다. 따라서, 서버에 요청을 보내 로그아웃을 구현한다.
    JWT는 토큰 자체에 만료 시간을 포함할 수 있지만, 이미 발급된 JWT를 서버에서 직접 만료시키는 것은 불가능하기 때문에 쿠키의 만료시간을 강제하여 쿠키를 삭제하는 방법으로 로그아웃한다.

    3. BlackList 추가
    서버에서 토큰을 무효화 시키는 방법이다. 서버에서 발급한 JWT를 블랙리스트에 추가하여 해당 토큰을 유효성을 없엔다. 이 방법은 추가적인 저장소를 필요로 한다는 단점이 있으며, 매번 블랙리스트에 있는 access 토큰인지 검증해야 할 필요가 생기므로 오버헤드가 발생한다. 
    또한 JWT를 블랙리스트에 저장하는 과정에서 stateless 하다는 장점을 잃게 된다.

### Access Token 탈취

    위에 글까지 보면, 간단하게 로그인부터 로그아웃까지 access token 하나만으로 구현이 가능하다. 하지만 access token 하나만을 사용한 상황에서 해커가 access token을 탈취하게 되면 어떻게 될까?

![accessToken_steal](/grammar/img/accessToken_steal.png)

    access 토큰을 사용 못하게 하는 방법은 무효화이다.
    하지만 서버는 해커가 가진 stateless한 access 토큰에 관한 정보가 하나도 없다. -> 서버는 만료 시간이 다 될 때까지 아무런 조치도 취할 수 없다.
    -> 이러한 서버의 하염없는 기다림의 대안은 blackList에 추가하는 방법이다.

    그러나 blacklist에 추가하는 것 역시 이상 패턴이 발견됐을 경우 이야기이지, 이상 패턴이 발견되지 않는다면 피해는 막을 수 없다.

    그러면 다른 방향으로 access 토큰 만료 기간을 짧게 가져가면 피해를 최소화할 수 있지 않을까?
    -> 위에 방식을 적용하면 해커는 토큰을 탈취했기 때문에 만료시간까지 공격할 수 있겠지만, 금방 만료되어 버린 토큰은 사용이 불가능해지므로 피해가 최소화되는 효과를 가져온다. 

    하지만, 이는 사용자의 경우에도 마찬가지이다. 홈페이지를 이용하는데, 10분마다 다시 로그인을 하려고 한다면, 사용자 경험이 저하되어 사용자는 줄어들게 될 것이다.
    -> 이런 토큰 유효기간의 딜레마를 해결하기 위해 access 토큰과 함께 refresh 토큰을 사용한다.

### Refresh Token    

